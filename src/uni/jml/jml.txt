ComputeScore

- modificare la specifica perchè la funzione sia totale:
--> devo mettere l' espressione che era nella require nella ensure e metto la negazione
    della require nella signals

------------------------------------------------------

Increment
incrementa gli elementi dell'array di interi ai del valore val

void increment(int[] ai, int val);

//@ assignable ai[*]
//@ requires ai != null
//@ ensures (\forall int i; 0 <= i < ai.length; a[i] == \old(a[i]) + val)

--- altra versione, che accetta ai = null e non fa nulla ---

//@ assignable ai[*]
//@ ensures ai!= null => (\forall .....)
-------------------------------------------------------------------------------------

Contains

boolean contains(int[] i1, int[] i2);

per gli array di interi i1 e i2 non nulli, restituisce vero se l'array i2 è contenuto nell'array
i1 (tutti gli elementi di i2 sono contenuti in i1, e in ordine).

//@ assignable \nothing
//@ requires i1 != null && i2 != null && i1.length >= i2.length
//@ ensures ((\exist int x ; x>=0 && x < i1.length-i2.length;
                (\forall int i; 0 <= i < i2.length; i2[i] == i1[i+x])) <=> \result == true)
            || \result == false

-------------------------------------------------------------------------------

Interval

dato un array non nullo e privo di duplicati x e due interi a e b, restituisce l'insieme di
interi in x compresi tra a e b. Si suppone che il tipo di dato astratto IntSet possegga il
metodo: boolean isIn(int n);

//@ assignable \nothing
//@ requires a<b && x!=null && (\forall int i; 0 < i < x.length;
                !(\exist int a; i < a < x.length; x[i] == x[a]))
//@ ensures (\forall int i;; (0 <= i < x.length && a <= x[i] <= b) => \result.isIn(x[i])) &&
            !(\exist int i ;; \result.isIn(i) && i>b && i<a)

IntSet interval(int[] x, int a, int b);



















